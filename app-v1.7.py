import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import Counter
from itertools import combinations

# --------- BIBLIOTH√àQUE DE SC√âNARIOS ---------
def get_scenario_components(scenario_type):
    if scenario_type == "Projet d‚Äôinnovation locale":
        return {
            "contexte": {"motivation": 0.7, "reseau": "mod√©r√©", "budget": "moyen"},
            "√©v√©nements": [
                {"nom": "formulation id√©e", "impact": 0.0, "base_prob": 0.1},
                {"nom": "refus de subvention", "impact": -0.3, "base_prob": 0.1},
                {"nom": "soutien b√©n√©vole", "impact": +0.3, "base_prob": 0.15},
                {"nom": "pivot strat√©gique", "impact": +0.4, "base_prob": 0.1},
                {"nom": "retard administratif", "impact": -0.2, "base_prob": 0.1},
                {"nom": "soutien mairie", "impact": +0.5, "base_prob": 0.1},
                {"nom": "√©puisement mental", "impact": -0.5, "base_prob": 0.05},
                {"nom": "mobilisation locale", "impact": +0.2, "base_prob": 0.15},
                {"nom": "lancement test", "impact": +0.3, "base_prob": 0.15},
            ],
        }
    elif scenario_type == "Recherche d‚Äôemploi en reconversion":
        return {
            "contexte": {"motivation": 0.8, "reseau": "faible", "budget": "faible"},
            "√©v√©nements": [
                {"nom": "mise √† jour CV", "impact": 0.0, "base_prob": 0.15},
                {"nom": "refus d‚Äôentretien", "impact": -0.3, "base_prob": 0.15},
                {"nom": "contact LinkedIn", "impact": +0.2, "base_prob": 0.15},
                {"nom": "formation courte", "impact": +0.3, "base_prob": 0.15},
                {"nom": "burnout", "impact": -0.4, "base_prob": 0.05},
                {"nom": "simulation d‚Äôentretien", "impact": +0.2, "base_prob": 0.15},
                {"nom": "job dating", "impact": +0.3, "base_prob": 0.15},
                {"nom": "recentrage objectif", "impact": +0.2, "base_prob": 0.1},
                {"nom": "proposition re√ßue", "impact": +0.5, "base_prob": 0.1},
            ],
        }
    elif scenario_type == "Lancement de projet entrepreneurial tech":
        return {
            "contexte": {"motivation": 0.9, "reseau": "fort", "budget": "moyen"},
            "√©v√©nements": [
                {"nom": "id√©e produit", "impact": 0.0, "base_prob": 0.1},
                {"nom": "prototype rapide", "impact": +0.4, "base_prob": 0.15},
                {"nom": "bug bloquant", "impact": -0.3, "base_prob": 0.1},
                {"nom": "pitch public", "impact": +0.3, "base_prob": 0.15},
                {"nom": "recherche associ√©", "impact": +0.2, "base_prob": 0.15},
                {"nom": "feedback client", "impact": +0.3, "base_prob": 0.15},
                {"nom": "absence de traction", "impact": -0.3, "base_prob": 0.1},
                {"nom": "demo √† un incubateur", "impact": +0.5, "base_prob": 0.1},
                {"nom": "retrait associ√©", "impact": -0.4, "base_prob": 0.05},
            ],
        }
    else:
        return {"contexte": {}, "√©v√©nements": []}

def contexte_score(context):
    score = context["motivation"] * 0.4
    if context["reseau"] == "mod√©r√©":
        score += 0.2
    elif context["reseau"] == "fort":
        score += 0.35
    if context["budget"] == "moyen":
        score += 0.2
    elif context["budget"] == "√©lev√©":
        score += 0.35
    return score

def simulate_one(event_list, base_score, weights):
    history = []
    score = base_score + np.random.normal(0, 0.1)
    n_steps = random.randint(6, 9)
    # Utilisation des pond√©rations modifi√©es
    probas = np.array([weights.get(e["nom"], e["base_prob"]) for e in event_list])
    probas = probas / probas.sum()
    chosen_events = np.random.choice(event_list, size=n_steps, replace=True, p=probas)
    for evt in chosen_events:
        history.append(evt["nom"])
        score += evt["impact"]
    if score >= 0.7:
        outcome = "succ√®s"
    elif score >= 0.5:
        outcome = "partiel"
    else:
        outcome = "√©chec"
    return {"steps": history, "outcome": outcome, "score": round(score, 2)}

def extract_top_pattern(df, outcome_filter):
    steps = df[df["outcome"] == outcome_filter]["steps"]
    combos = Counter()
    for s in steps:
        pairs = combinations(sorted(set(s)), 2)
        for p in pairs:
            combos[p] += 1
    return combos.most_common(1)[0] if combos else (None, 0)

def extract_pattern_perdant_all(df):
    fails = df[df["outcome"] == "√©chec"]["steps"]
    combos_fail = Counter()
    for s in fails:
        for p in combinations(sorted(set(s)), 2):
            combos_fail[p] += 1
    return combos_fail.most_common(5) if combos_fail else []

# --- Streamlit UI ---
st.set_page_config(layout="centered")
st.title("üîÆ Simulateur de futurs ‚Äî V6 avec pond√©rations & immersion")

scenario_type = st.selectbox("Choisis un cas de figure", [
    "Projet d‚Äôinnovation locale",
    "Recherche d‚Äôemploi en reconversion",
    "Lancement de projet entrepreneurial tech"
])

components = get_scenario_components(scenario_type)
base = contexte_score(components["contexte"])

st.markdown("## üéõÔ∏è Ajuste les pond√©rations d'apparition des √©v√©nements (entre 0 et 1)")

weights = {}
cols = st.columns(3)
for i, evt in enumerate(components["√©v√©nements"]):
    col = cols[i % 3]
    w = col.slider(f"{evt['nom']} (impact: {evt['impact']})", 0.0, 1.0, float(evt["base_prob"]), 0.01)
    weights[evt["nom"]] = w

n_simulations = st.slider("Nombre de simulations", 10, 2000, 500)

# G√©n√©ration des simulations
df = pd.DataFrame([simulate_one(components["√©v√©nements"], base, weights) for _ in range(n_simulations)])

st.markdown("## üìä R√©sum√© des simulations")
st.write(df["outcome"].value_counts())

# Synth√®se patterns gagnants / perdants
with st.expander("üß† Synth√®se strat√©gique", expanded=True):
    total_succ = len(df[df["outcome"] == "succ√®s"])
    total_fail = len(df[df["outcome"] == "√©chec"])

    p_win, n_win = extract_top_pattern(df, "succ√®s")
    if p_win:
        pct_win = n_win / total_succ * 100 if total_succ > 0 else 0
        st.markdown(f"üîç **Pattern gagnant d√©tect√©** : `{p_win[0]}` + `{p_win[1]}` ({n_win} sc√©narios, soit {pct_win:.1f} % des succ√®s)")
        st.markdown("‚úÖ Ce pattern est rare dans les √©checs ‚Üí il semble fortement corr√©l√© au succ√®s.")
        st.markdown("### üõ†Ô∏è Ligne d'action sugg√©r√©e :")
        st.markdown(f"‚Üí Favoriser l'apparition de `{p_win[0]}`, puis `{p_win[1]}` d√®s que possible.")
    else:
        st.info("Pas assez de donn√©es pour d√©tecter un pattern gagnant clair.")

    st.markdown("---")

    perdants = extract_pattern_perdant_all(df)
    if perdants:
        st.markdown("‚ùå **Principaux patterns pr√©sents dans les √©checs :**")
        for combo, count in perdants:
            pct = count / total_fail * 100 if total_fail > 0 else 0
            st.markdown(f"- `{combo[0]}` + `{combo[1]}` ‚Üí pr√©sent dans {count} sc√©narios d‚Äô√©chec ({pct:.1f} % des √©checs)")
        st.markdown("### ‚ö†Ô∏è Ligne d‚Äôalerte strat√©gique :")
        st.markdown("‚Üí Surveille ces combinaisons dans tes sc√©narios : elles sont fortement pr√©sentes dans les √©checs.")

        st.markdown("### üìâ Visualisation des patterns d‚Äô√©chec")
        labels = [f"{c[0]} + {c[1]}" for c, _ in perdants]
        values = [count for _, count in perdants]
        fig, ax = plt.subplots()
        sns.barplot(x=values, y=labels, ax=ax, palette="Reds_r")
        ax.set_title("Patterns fr√©quents dans les √©checs")
        ax.set_xlabel("Nombre d‚Äôoccurrences")
        ax.set_ylabel("Combinaisons d‚Äô√©v√©nements")
        st.pyplot(fig)
    else:
        st.info("Aucun encha√Ænement d'√©v√©nements fr√©quent d√©tect√© dans les √©checs.")

# --- Exploration immersive d'un sc√©nario ---
st.markdown("---")
st.markdown("## üé≠ Exploration immersive d'un sc√©nario")

filter_outcome = st.selectbox("Filtrer par r√©sultat", options=["Tous", "succ√®s", "partiel", "√©chec"])

if filter_outcome == "Tous":
    filtered_df = df.copy()
else:
    filtered_df = df[df["outcome"] == filter_outcome]

idx = st.selectbox(f"S√©lectionne un sc√©nario parmi {len(filtered_df)}", filtered_df.index)

scenario = filtered_df.loc[idx]
steps = scenario["steps"]
score = scenario["score"]
outcome = scenario["outcome"]

st.markdown(f"### R√©sultat : **{outcome.upper()}** avec un score final de {score}")

# Affichage timeline et analyse
st.markdown("#### Timeline des √©v√©nements")
cumulative_score = contexte_score(components["contexte"]) + np.random.normal(0,0.1)
scores_timeline = [cumulative_score]
for evt_name in steps:
    # chercher impact
    impact = next(e["impact"] for e in components["√©v√©nements"] if e["nom"] == evt_name)
    cumulative_score += impact
    scores_timeline.append(cumulative_score)

fig, ax = plt.subplots(figsize=(8, 3))
ax.plot(range(len(scores_timeline)), scores_timeline, marker='o')
for i, evt_name in enumerate(steps, 1):
    impact = next(e["impact"] for e in components["√©v√©nements"] if e["nom"] == evt_name)
    color = "green" if impact >= 0 else "red"
    ax.annotate(evt_name, (i, scores_timeline[i]), color=color, fontsize=9, rotation=45, ha="right", va="bottom")
ax.axhline(y=0.7, color='blue', linestyle='--', label='Seuil succ√®s')
ax.axhline(y=0.5, color='orange', linestyle='--', label='Seuil partiel')
ax.set_xlabel("√âtapes")
ax.set_ylabel("Score cumulatif")
ax.set_title("√âvolution du score dans ce sc√©nario")
ax.legend()
plt.tight_layout()
st.pyplot(fig)

# Mini-analyse pond√©r√©e des √©v√©nements
st.markdown("#### Analyse d√©taill√©e du sc√©nario")
counter_evt = Counter(steps)
total_evt = len(steps)
st.write(f"Nombre d‚Äô√©tapes : {total_evt}")

evt_weights = []
for evt_name, count_evt in counter_evt.items():
    impact = next(e["impact"] for e in components["√©v√©nements"] if e["nom"] == evt_name)
    weighted_impact = impact * count_evt
    evt_weights.append((evt_name, count_evt, impact, weighted_impact))

evt_weights.sort(key=lambda x: abs(x[3]), reverse=True)
df_evt = pd.DataFrame(evt_weights, columns=["√âv√©nement", "Occurrences", "Impact unitaire", "Impact total (pond√©r√©)"])
st.dataframe(df_evt)

# Interpr√©tation synth√©tique
st.markdown("##### Synth√®se interpr√©tative")
strong_events = [e for e in evt_weights if abs(e[3]) > 0.3]
if strong_events:
    for evt_name, count_evt, impact, weighted_impact in strong_events:
        action = "a permis un gain" if weighted_impact > 0 else "a frein√© la progression"
        st.markdown(f"> - L‚Äô√©v√©nement **‚Äò{evt_name}‚Äô** ({count_evt} fois) {action} de {abs(weighted_impact):.2f} points, important pour ce sc√©nario.")
else:
    st.markdown("Pas d‚Äô√©v√©nement dominant particulier dans ce sc√©nario.")

